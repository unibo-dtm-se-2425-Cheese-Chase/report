---
title: Release
has_children: false
nav_order: 7
---

# Release

The release process for Cheese-Chase has been designed to ensure that the game is easy to distribute, install, and maintain. From the projectâ€™s codebase, different artefacts are produced depending on the release target. The fundamental outputs are a compressed source archive in .tar.gz format and a prebuilt wheel file, which together represent the standard distribution formats for Python projects. These artefacts make the game directly installable through the Python Package Index (PyPI). In addition to these, the project may also generate standalone executables using PyInstaller. Such executables allow the game to run independently of a Python installation, making them particularly suitable for casual players who may not be familiar with programming environments.

Releases are distributed through two main platforms:

- On GitHub, the repository hosts both the codebase and downloadable releases, which include the source code and, when appropriate, standalone executables. This approach ensures transparency while providing developers with direct access to the underlying implementation.
  
- On PyPI, the packaged versions of the game are made publicly available, allowing anyone to install Cheese-Chase with a single command. This lowers the barrier to entry for users who simply wish to play the game without dealing with the repository.

The release procedure itself combines manual and automated elements. GitHub releases are typically created manually. Developers create a new version tag and attach executables when they are available. In contrast, publishing to PyPI is largely automated. 

Continuous integration pipelines use GitHub Actions to test the code, build distribution packages, and upload them to PyPI whenever a new version tag is pushed. This approach ensures that every public release has passed testing while still giving developers the freedom to control when stable versions are made available.

Although automation handles most of the process, releases can also be prepared manually. Developers may build the package locally using the command python -m build, after which the generated distribution files can be uploaded with python -m twine upload dist/*.

## Choice of the license

The project is distributed under the Apache License 2.0, chosen for its permissive and widely recognised nature. This license permits modification and redistribution, while requiring only minimal attribution and providing explicit protections regarding liability and patents. 

By applying the same license to both the codebase and the artefacts, the project maintains consistency and encourages reuse in educational, research, or personal contexts.

## Choice of the versioning schema

Versioning in Cheese-Chase is managed automatically using the Semantic Versioning (SemVer) standard in combination with the semantic-release tool. Versions follow the Major.Minor.Patch format, where the number communicates the type of change. Major versions are incremented when incompatible changes are introduced, such as a redesign of the game engine. Minor versions increase when new features are added without breaking existing functionality, for example, the addition of new levels. Patch versions are reserved for bug fixes or small improvements. All artefacts generated by the pipeline, including source distributions and wheel files, share the same version number to maintain consistency.

The process is fully automated through GitHub Actions. Developers only need to commit and push code to the main branch. The workflow runs the test suite and, if successful, invokes semantic-release, which analyzes commit messages written in the Conventional Commit style. Based on these keywords, the tool determines the appropriate version bump: commits starting with fix: trigger a patch release, commits starting with feat: trigger a minor release, and commits containing BREAKING CHANGE cause a major release.

Semantic-release then creates the corresponding Git tag, builds the artefacts, and publishes them directly to PyPI using stored repository credentials. Development builds are also supported: when commits are pushed without a formal release trigger, they are marked with a .dev suffix to distinguish them from stable versions.

For example, a bug fix commit like fix: resolve collision issue would produce version 1.0.1. A commit such as feat: add special cheese mechanic would instead lead to 1.1.0, while a commit with BREAKING CHANGE: new rendering engine would increment to 2.0.0. Thanks to this setup, the release process is transparent, predictable, and requires no manual intervention beyond writing properly formatted commits.
